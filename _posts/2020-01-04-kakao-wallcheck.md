---
layout: post
title: "[2020 카카오 코딩테스트] 외벽 점검 문제 풀이 (프로그래머스)"
date: 2021-01-04
categories: kakao
photos: /assets/post_images/kakao/wallcheck.png
tags: [ps,algorithm,c++,kakao,programmers,bruteforce,implementation]
description: "2020 카카오 블라인드 채용 코딩테스트 - 외벽 점검 C++ 풀이 (프로그래머스)"
---

<br>

# 문제 설명

레스토랑을 운영하고 있는 스카피는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.

레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.

외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.

<br>

# 제한사항

- n은 1 이상 200 이하인 자연수입니다.
- weak의 길이는 1 이상 15 이하입니다.
    - 서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.
    - 취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.
    - weak의 원소는 0 이상 n - 1 이하인 정수입니다.
- dist의 길이는 1 이상 8 이하입니다.
    - dist의 원소는 1 이상 100 이하인 자연수입니다.
- 친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.

<br>

# 입출력 예

|n|weak|dist|result|
|---|-----|-----|---|
|12|[1, 5, 6, 10]|[1, 2, 3, 4]|2|
|12|[1, 3, 4, 9, 10]|[3, 5, 7]|1|

<br>

# 입출력 예에 대한 설명

원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.

![img](https://grepp-programmers.s3.amazonaws.com/files/production/61de504978/1c8394ec-05e0-4b7b-a0ff-3ff9ae0cec28.jpg)

친구들을 투입하는 예시 중 하나는 다음과 같습니다.

- 4m를 이동할 수 있는 친구는 10m 지점에서 출발해 시계방향으로 돌아 1m 위치에 있는 취약 지점에서 외벽 점검을 마칩니다.
- 2m를 이동할 수 있는 친구는 4.5m 지점에서 출발해 6.5m 지점에서 외벽 점검을 마칩니다.

그 외에 여러 방법들이 있지만, 두 명보다 적은 친구를 투입하는 방법은 없습니다. 따라서 친구를 최소 두 명 투입해야 합니다.

<br>

# 풀이

문제를 처음 읽고 `탐욕법` 을 떠올리는 사람들이 많을 것이다. 하지만 문제의 입력 숫자 크기 제한을 보고 `완전탐색` 으로도 해결 가능한 문제인 것을 눈치챌 수 있어야 했다. 필자 또한 처음엔 `탐욕법` 을 시도해보느라 머리를 싸매다가 나중에서야 `완전탐색` 문제임을 깨닫고 다시 시도해본 케이스이다. 하지만 `완전탐색` 문제임을 깨닫고도 코드를 떠올리고 `구현`하기까지 꽤 많은 고민이 필요했다. 여러모로 상당히 까다로운 문제였다.

우선 첫번째 난관은 외벽이 `원형`이라는 점이다. `0번` 지점을 거쳐가는 경로가 존재할 수 있기 때문에 단순한 `1차원 배열`로 외벽을 표현하기엔 부족하다. 이때 사용할 수 있는 기법이 **배열의 길이를 `2배` 늘려주는 것**이다.

<br>

> n=12 이고 weak = [1, 5, 6, 10] 일 때 weak = [1, 5, 6, 10, **13, 17, 18, 22**] 로 표현한다.

<br>

이렇게 표현하고 나면 다음과 같은 사실을 알 수 있다.

<br>

> **모든 K개의 외벽을 검사하는 것은 변형된 `weak` 배열에서 임의의 연속된 K개의 정점을 방문하는 것과 동일하다.**

<br>

이것을 깨닫고 나면 어떤 방식으로 `완전탐색` 코드를 짤지 어느정도 감을 잡을 수 있다.

또 한 가지 고려해야 하는 것은 바로 **어떤 친구**에게 **어느 벽**의 청소를 맡길 것인지에 대한 사항이다. 벽에 대한 `완전탐색`은 위에서 해결됐으므로 친구들의 **투입 순서**만 고려해주면 된다. 다르게 말하면 `dist` 배열의 모든 **순열**에 대하여 `weak` 배열의 모든 구간을 탐색하면 모든 경우의 수를 방문할 수 있다. 순열은 `dist` 배열을 정렬한 후 `C++ STL` 의 `next_permutation` 을 통해 간단히 구할 수 있다.

<br>

# 전체 코드

```c++
#include <vector>
#include <algorithm>
using namespace std;

int solution(int n, vector<int> weak, vector<int> dist) {
    int answer = 1e9;
	int W = weak.size();

    // 원형에 대한 weak 배열 가공
	weak.resize(2*W);
	for(int i=W;i<weak.size();i++)
		weak[i] = weak[i-W]+n;

	sort(dist.begin(),dist.end()); // 순열 계산을 위한 정렬

	do{
		for(int i=0;i<W;i++){
			int start = weak[i]; // 검사 시작 지점
			int finish = weak[i+W-1]; // 검사 종료 예상 지점
			for(int j=0;j<dist.size();j++){
				start += dist[j];
				if(start >= finish){ // 모든 지점 방문 완료 시 탈출
					answer = min(answer,j+1);
					break;
				}
                // 다음 검사 시작 지점 구하기
                // => 마지막에 방문한 지점보다 큰 weak 지점 중 가장 작은 지점
				int next = upper_bound(weak.begin(),weak.end(),start)-weak.begin();
				start = weak[next];
			}
		}
	}while(next_permutation(dist.begin(),dist.end())); // 모든 순열에 대한 탐색

	if(answer == 1e9) return -1;

    return answer;
}
```