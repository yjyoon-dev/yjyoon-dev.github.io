---
layout: post
title: "[프로그래머스] 주차 요금 계산 풀이 (2022 카카오 코딩테스트)"
date: 2022-01-16
categories: kakao
photos: /assets/post_images/kakao/2022-blind-03.png
tags: [ps, kakao, programmers, algorithm, c++, string, implementation]
description: "프로그래머스 - 주차 요금 계산 C++ 풀이 (2022 카카오 블라인드 채용 1차 코딩테스트)"
---

<br>

# 문제 설명

주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다.

- 요금표

기본 시간(분) | 기본 요금(원) | 단위 시간(분) | 단위 요금(원)
---|---|---|---
180|5000|10|600


- 입/출차 기록
  
시각(시:분)|차량 번호|내역
---|---|---
05:34|5961|입차
06:00|0000|입차
06:34|0000|출차
07:59|5961|출차
07:59|0148|입차
18:59|0000|입차
19:09|0148|출차
22:59|5961|입차
23:00|5961|출차

- 자동차별 주차 요금
  
차량 번호|누적 주차 시간(분)|주차 요금(원)
---|---|---
0000|34 + 300 = 334|5000 + ⌈(334 - 180) / 10⌉ x 600 = 14600
0148|670|5000 +⌈(670 - 180) / 10⌉x 600 = 34400
5961|145 + 1 = 146|5000

- 어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다.
    - 0000번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다.
- 00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다.
- 누적 주차 시간이 기본 시간이하라면, 기본 요금을 청구합니다.
- 누적 주차 시간이 기본 시간을 초과하면, 기본 요금에 더해서, 초과한 시간에 대해서 단위 시간 마다 단위 요금을 청구합니다.
    - 초과한 시간이 단위 시간으로 나누어 떨어지지 않으면, 올림합니다.
    - ⌈a⌉ : a보다 작지 않은 최소의 정수를 의미합니다. 즉, 올림을 의미합니다.

주차 요금을 나타내는 정수 배열 fees, 자동차의 입/출차 내역을 나타내는 문자열 배열 records가 매개변수로 주어집니다. **차량 번호가 작은 자동차부터** 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

<br>

# 제한사항

- `fees`의 길이 = 4
    - fees[0] = `기본 시간(분)`
    - 1 ≤ fees[0] ≤ 1,439
    - fees[1] = `기본 요금(원)`
    - 0 ≤ fees[1] ≤ 100,000
    - fees[2] = `단위 시간(분)`
    - 1 ≤ fees[2] ≤ 1,439
    - fees[3] = `단위 요금(원)`
    - 1 ≤ fees[3] ≤ 10,000
- 1 ≤ `records`의 길이 ≤ 1,000
  - `records`의 각 원소는 `"시각 차량번호 내역"` 형식의 문자열입니다.
  - `시각`, `차량번호`, `내역`은 하나의 공백으로 구분되어 있습니다.
  - `시각`은 차량이 입차되거나 출차된 시각을 나타내며, `HH:MM` 형식의 길이 5인 문자열입니다.
    - `HH:MM`은 00:00부터 23:59까지 주어집니다.
    - 잘못된 시각("25:22", "09:65" 등)은 입력으로 주어지지 않습니다.
  - `차량번호`는 자동차를 구분하기 위한, `0'~'9'로 구성된 길이 4인 문자열입니다.
  - 내역은 길이 2 또는 3인 문자열로, `IN` 또는 `OUT`입니다. `IN`은 입차를, `OUT`은 출차를 의미합니다.
  - `records`의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다.
  - `records`는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다.
  - 같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다.
  - 마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다.
  - 아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다.
    - 주차장에 없는 차량이 출차되는 경우
    - 주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우

<br>

# 풀이

그저 문제에서 요구하는 바를 그대로 구현만 하면 되는 `구현` 문제였다. 문제를 꼼꼼히 읽지 않아 놓칠만한 조건들은 다음과 같다.

- 주차 요금은 주차 시간의 **누적값**으로 판단한다
- `23:59` 때의 출차는 표기되어 있지 않다
- 차량 번호가 작은 자동차 순으로 반환한다

문제에서 위와 같은 조건을 놓치지 않았다면 큰 시간 투자없이 빠르게 풀어낼 수 있었을 것이다.

풀이에 대한 아이디어는 아래 코드를 참조하는 것으로 쉽게 확인할 수 있다.

<br>

# 전체 코드

```c++
#include <string>
#include <sstream>
#include <vector>
#include <map>
using namespace std;

map<string,int> parkingTime; // 차량당 누적 주차 시간
map<string,string> parkingLog; // 차량당 주차 시간 기록

// 요금 계산
int calcFee(vector<int>& fees, int t) {
    int baseTime = fees[0]; int baseFee = fees[1];
    int unitTime = fees[2]; int unitFee = fees[3];
    
    if(t <= baseTime) return baseFee;
    
    t -= baseTime;
    
    if(t%unitTime == 0) t /= unitTime;
    else t = t/unitTime+1;
    
    return baseFee + t * unitFee;
}

// from ~ to 시간(분) 차이 계산
int calcTime(string from, string to) {
    return (stoi(to.substr(0,2))*60+stoi(to.substr(3,2)))
        - (stoi(from.substr(0,2))*60+stoi(from.substr(3,2)));    
}

vector<int> solution(vector<int> fees, vector<string> records) {
    vector<int> answer;
    
    for(string s: records) {
        string time, num, opt;
        stringstream ss(s);
        ss >> time >> num >> opt;
        
        // 주차 시간 누적 후 기록 삭제
        if(opt == "OUT") {
            parkingTime[num] += calcTime(parkingLog[num],time);
            parkingLog.erase(num);
        }
        // 주차 기록 등록
        else parkingLog[num] = time;
    }
    
    // 아직 남아있는 기록에 대하여 23:59 출차 처리
    for(auto iter=parkingLog.begin(); iter!=parkingLog.end(); iter++)
        parkingTime[iter->first] += calcTime(iter->second,"23:59");
    
    // map 자료구조의 경우 key 값에 따른 자동 정렬 (낮은 차량 번호부터)
    for(auto iter=parkingTime.begin(); iter!=parkingTime.end(); iter++)
        answer.push_back(calcFee(fees,iter->second));
        
    return answer;
}
```