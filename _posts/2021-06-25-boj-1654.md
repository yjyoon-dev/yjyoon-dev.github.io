---
layout: post
title: "[BOJ] 백준 1654번 랜선 자르기 풀이"
date: 2021-06-25
categories: BOJ
photos: /assets/post_images/boj/1654.png
tags: [ps, boj, algorithm, c++, binary_search]
description: "백준 온라인 저지 백준 1654번 - 랜선 자르기 C++ 풀이"
---

<br>

# 문제

집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.

이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)

편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.

<br>

# 출력

첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 2^31-1보다 작거나 같은 자연수이다.

<br>

# 입력

첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.

<br>

# 풀이

정답률 `20%` 로 비슷한 난이도 문제들 중에서는 까다로운 편에 속하는 문제이다. 그런데 문제 자체는 정말 좋은 문제이다. 이 문제의 핵심은 우선 문제를 보고 `이분 탐색`을 떠올릴 수 있는지 없는지로 나뉜다. `이분 탐색`을 단순히 다음과 같이 생각하고 있다면 위 문제를 보고 `이분 탐색`을 떠올리기 힘들 것이다.

> 이분 탐색은 단순히 **정렬되어 있는 배열**에서 **특정 원소**를 찾는 알고리즘이 아니었나...?

위 문장을 좀 더 고민해보고 다음과 같이 바꿔보자.

- _정렬되어 있는 배열_ → **_가능한 모든 답의 나열_**
- _특정 원소_ → **_문제의 답_**

그렇다면 다음과 같은 문장이 완성된다.

> 이분 탐색은 **가능한 모든 답의 나열**에서 **문제의 답**을 찾는 알고리즘!

이제 이 문제에 `이분 탐색`을 어떻게 적용할 수 있을지 보일 것이다. 그리고 가능한 모든 답의 범위는 `1 ~ (랜선 길이 중 최댓값)` 임은 쉽게 알 수 있다.

그리고 이외에도 다음과 같이 우리에게 오답을 안겨줄 수 있는 두 가지 요소가 있다.

- 문제에 대한 올바른 이해
- 큰 수

우선 문제를 똑바로 이해할 필요가 있는데, 놓치기 쉬운 요소는 바로 **모든 랜선이 동일한 길이가 될 필요가 없다**라는 것이다. 어떻게든 동일한 길이를 갖는 랜선의 개수가 **N개만 넘으면** 된다. 따라서 어떠한 랜선은 아예 자르지도 않고 없는 셈 쳐도 될 수 있다.

그리고 이 문제에서 랜선 하나의 최대 길이는 `2^31-1` 로 `int`형 최대 범위보다 고작 `1`이 작은 길이다. 따라서 `이분 탐색` 진행 중에 `mid` 값을 구하기 위해 막대의 길이를 더하는 과정에서 `오버플로우`가 일어나게 된다. 이런 문제는 변수 하나하나 깊게 생각하지 않고 그냥 여기저기 `long long`을 붙여주는 것이 좋다.

`이분 탐색`의 기본적인 개념만 있다면 어렵지 않게 아래 코드를 이해할 수 있다.

<br>

# 전체 코드

```c++
#include <iostream>
#include <vector>
using namespace std;

int check(vector<long long>& v, int mid){
   int ret=0;
   for(long long ll:v) ret+=ll/mid;
   return ret;
}

int main(){
   ios_base::sync_with_stdio(0);
   cin.tie(0); cout.tie(0);

   int K,N; cin>>K>>N;
   long long lo=1,hi=0;
   vector<long long> v(K);

   while(K--){
      cin>>v[K];
      hi=max(hi,v[K]);
   }

   while(lo<=hi){
      long long mid=(lo+hi)/2;
      if(check(v,mid)>=N) lo=mid+1;
      else hi=mid-1;
   }

   cout<<lo-1;

   return 0;
}
```
