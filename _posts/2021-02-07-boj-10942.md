---
layout: post
title: "[BOJ][쿠팡 기출] 백준 10942번 - 팰린드롬? 풀이"
date: 2021-02-07
categories: BOJ
photos: /assets/post_images/boj/10942.png
tags: [ps,boj,algorithm,c++,coupang,string,dynamic_programming]
description: "백준 온라인 저지 백준 10942번 - 팰린드롬? C++ 풀이 (쿠팡 코딩테스트 기출)"
---

<br>

# 문제

명우는 홍준이와 함께 팰린드롬 놀이를 해보려고 한다.

먼저, 홍준이는 자연수 N개를 칠판에 적는다. 그 다음, 명우에게 질문을 총 M번 한다.

각 질문은 두 정수 S와 E(1 ≤ S ≤ E ≤ N)로 나타낼 수 있으며, S번째 수부터 E번째 까지 수가 팰린드롬을 이루는지를 물어보며, 명우는 각 질문에 대해 팰린드롬이다 또는 아니다를 말해야 한다.

예를 들어, 홍준이가 칠판에 적은 수가 1, 2, 1, 3, 1, 2, 1라고 하자.

- S = 1, E = 3인 경우 1, 2, 1은 팰린드롬이다.
- S = 2, E = 5인 경우 2, 1, 3, 1은 팰린드롬이 아니다.
- S = 3, E = 3인 경우 1은 팰린드롬이다.
- S = 5, E = 7인 경우 1, 2, 1은 팰린드롬이다.

자연수 N개와 질문 M개가 모두 주어졌을 때, 명우의 대답을 구하는 프로그램을 작성하시오.

<br>

# 입력

첫째 줄에 수열의 크기 N (1 ≤ N ≤ 2,000)이 주어진다.

둘째 줄에는 홍준이가 칠판에 적은 수 N개가 순서대로 주어진다. 칠판에 적은 수는 100,000보다 작거나 같은 자연수이다.

셋째 줄에는 홍준이가 한 질문의 개수 M (1 ≤ M ≤ 1,000,000)이 주어진다.

넷째 줄부터 M개의 줄에는 홍준이가 명우에게 한 질문 S와 E가 한 줄에 하나씩 주어진다.

<br>

# 출력

총 M개의 줄에 걸쳐 홍준이의 질문에 대한 명우의 답을 입력으로 주어진 순서에 따라서 출력한다. 팰린드롬인 경우에는 1, 아닌 경우에는 0을 출력한다.

<br>

# 풀이

백준에 쿠팡 기출도 올라오는지 몰랐는데 이 문제가 쿠팡 기출문제라고 해서 풀어보았다.

이 문제는 `시간 초과` 를 고려하지 않으면 아주 단순한 알고리즘으로 풀 수 있다.
`S`,`E` 입력이 주어질 때마다 해당 구간을 끝에서부터 비교하여 `팰린드롬` 인지 확인해주면 된다. 하지만 문자열의 최대 길이가 `2000` 이고 쿼리의 최대 수가 `1000000` 이므로 시간복잡도 **O(N*M)** 으로는 시간 내에 해결할 수 없다.

**모든 고난이도 `다이나믹 프로그래밍` 문제가 그렇듯 이 문제가 `DP` 문제임을 깨닫는 것이 가장 어려운 부분이다.**

`DP` 문제의 전제는 작업을 단계별로 작게 쪼갰을 때 각 단계마다 모두 **동일한** 작업을 수행하여 모든 작업을 수행할 수 있어야 한다는 것이다. 즉, **재귀적인** 해법이 존재하고 이에 따른 **점화식**을 세울 수 있어야 한다는 것이다.

이 문제는 다음과 같이 재귀적인 접근으로 해결할 수 있다.

> dp[s][e] = arr[s..e] 의 팰린드롬 여부라고 하면
> 
> dp[s][e] = arr[s]==arr[e] && dp[s+1][d-1]

즉, 팰린드롬 여부는 양 끝의 숫자가 같고 그 안쪽의 숫자가 팰린드롬을 이루는지만 확인하면 알 수 있다는 것이다.

이 때 기저사례는 다음과 같다.

- **S == E** : 길이가 1인 문자열은 무조건 팰린드롬
- **S+1 == E** : 길이가 2인 문자열은 두 문자가 같아야 팰린드롬

가장 작은 단위인 위 두 가지 사례만 기저 사례로 처리해주면 `재귀`와 `메모이제이션` 을 통해 문제를 해결할 수 있다.

<br>

# 전체 코드

```c++
#include <iostream>
#include <cstring>
using namespace std;

int arr[2000];
int cache[2000][2000];

int solve(int s, int e){
    // 기저 사례
    if(s==e) return 1;
    if(s+1==e) return arr[s]==arr[e];

    int& ret = cache[s][e];
    if(ret!=-1) return ret;

    return ret = (arr[s]==arr[e] && solve(s+1,e-1));
}

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    int N; cin>>N;
    for(int i=0;i<N;i++) cin>>arr[i];

    int M; cin>>M;
    memset(cache,-1,sizeof(cache));

    while(M--){
        int s,e; cin>>s>>e;
        cout<<solve(s-1,e-1)<<'\n';
    }

    return 0;
}
```




