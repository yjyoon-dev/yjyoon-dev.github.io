---
layout: post
title: "[BOJ] 백준 1920번 수 찾기 풀이"
date: 2021-06-24
categories: BOJ
photos: /assets/post_images/boj/1920.png
tags: [ps, boj, algorithm, c++, set]
description: "백준 온라인 저지 백준 1920번 - 수 찾기 C++ 풀이"
---

<br>

# 문제

N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.

<br>

# 입력

첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -2^31 보다 크거나 같고 2^31보다 작다

<br>

# 출력

M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.

<br>

# 풀이

`집합` 알고리즘을 사용하는 가장 간단한 형태의 문제이다. 이 문제의 대표적인 잘못된 접근 방법은 `M`개의 수를 입력받을 때 매 번 배열 `A`를 체크하는 것이다. 이렇게 되면 최악의 경우 `100,000`개의 수마다 `100,000` 길이의 배열을 탐색하게 되므로 `100,000` 의 제곱에 해당되는 연산을 거치게 되므로 `시간 초과`가 발생한다. 따라서 입력받은 배열 A를 `집합` 자료구조에 저장하여 특정 수가 존재하는지 `로그 시간`내에 확인해야 한다. `C++`의 `STL`에서 제공하는 `set` 자료구조의 경우 특정 원소 탐색에 걸리는 시간은 `O(logN)` 이므로 이를 사용하면 된다. 이 외에 `unordered_set` 자료구조 또한 존재하는데, 이는 `트리 구조`를 갖는 `set`에 반해 `해시 자료구조`를 갖는다. 따라서 원소 탐색에 걸리는 시간이 `O(1)`, 즉 상수 시간이다! 하지만 `해시`의 특성상 원소이 개수가 많아질 수록 효율이 떨어지고 최악의 경우 `O(N)`의 시간복잡도를 갖는다. 따라서 원소의 개수가 적을 때만 적절히 사용해주어야 `set`보다 높은 효율의 결과를 얻을 수 있다. 하지만 거의 대부분의 `알고리즘` 문제에서는 `unordered_set` 자료구조를 사용해주는 것이 `set`을 사용했을 때보다 아주 미미하게 빠른 경향이 나타난다. 그런데 이 차이가 큰 의미가 없어서 대부분 타이핑이 쉬운 `set`을 주로 사용한다. 이 문제의 같은 경우 `unordered_set`을 사용했을 때가 `set`보다 약 `10%` 정도 빠른 것을 확인할 수 있었다.

<br>

# 전체 코드

```c++
#include <iostream>
#include <unordered_set> // set으로 대체 가능
using namespace std;

int main(){
   ios_base::sync_with_stdio(0);
   cin.tie(0); cout.tie(0);

   int N; cin>>N;
   unordered_set<int> s; // set으로 대체 가능
   while(N--){
      int n; cin>>n;
      s.insert(n);
   }

   int M; cin>>M;
   while(M--){
      int n; cin>>n;
      cout<<(s.find(n)!=s.end())<<'\n';
   }

   return 0;
}
```
